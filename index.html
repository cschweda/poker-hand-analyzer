<!DOCTYPE html>
<html lang="en" class="w-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Interactive JavaScript Poker Hand Analyzer with bitwise operations explanation"
    />
    <title>Poker Hand Analyzer</title>
  </head>
  <body class="bg-gray-950 text-white min-h-screen w-full">
    <div class="container mx-auto w-full">
      <h1 class="text-center mb-8">JavaScript Poker Hand Analyzer Explained</h1>

      <section class="content-section">
        <h2>Introduction</h2>
        <p>
          This page explores a clever JavaScript function designed to analyze a
          5-card poker hand and determine its rank (e.g., Pair, Straight,
          Flush). What makes this analyzer unique is its heavy reliance on
          bitwise and mathematical operations rather than traditional
          conditional logic (if/else statements).
        </p>
        <p>
          The original author aimed to create a concise and potentially fast
          algorithm by exploiting JavaScript's features like weakly typed
          variables (implicit type conversions) and the 52-bit mantissa used in
          its floating-point number representation. While the resulting code is
          compact, it's less readable than a standard approach. However,
          understanding its mechanics offers insight into bit manipulation
          techniques.
        </p>
      </section>

      <section class="content-section">
        <h2>Original Code Snippet</h2>
        <p>
          Below is the core `rankPokerHand` function from the original source,
          along with its helper variables and some example calls.
        </p>
        <pre><code class="language-javascript">
// Array to map the final calculated index to hand names
const hands = [
    "4 of a Kind", "Straight Flush", "Straight", "Flush", "High Card",
    "1 Pair", "2 Pair", "Royal Flush", "3 of a Kind", "Full House"
];
// Card rank constants (Ace high)
const A=14, K=13, Q=12, J=11;
// Suit flags (using powers of 2 for potential bitwise operations)
const _ = { "♠":1, "♣":2, "♥":4, "♦":8 };

// Calculates the Rank of a 5 card Poker hand using bit manipulations.
function rankPokerHand(cs, ss) {
  console.log('Input:', { cards: cs, suits: ss });
  
  // Create bit field for ranks
  var s = 1&lt;&lt;cs[0]|1&lt;&lt;cs[1]|1&lt;&lt;cs[2]|1&lt;&lt;cs[3]|1&lt;&lt;cs[4];
  console.log('Rank bit field:', s.toString(2).padStart(32, '0'));
  
  // Calculate hand value
  var v, i, o;
  for (i=-1, v=o=0; i&lt;5; i++, o=Math.pow(2,cs[i]*4)) {
    var prevV = v;
    v += o*((v/o&amp;15)+1);
    console.log(`Step ${i+1}:`, {
      cardRank: i >= 0 ? cs[i] : 'init',
      offset: o,
      prevValue: prevV,
      newValue: v,
      groupCount: (v/o&amp;15)
    });
  }
  
  // Check for straights
  var isStraight = s/(s&amp;-s) == 31;
  var isAceLowStraight = s == 0x403c;
  console.log('Straight detection:', {
    normalStraight: isStraight,
    aceLowStraight: isAceLowStraight,
    bitPattern: s.toString(16)
  });
  
  v = v % 15;
  console.log('After mod 15:', v);
  
  v = v - (isStraight || isAceLowStraight ? 3 : 1);
  console.log('After straight adjustment:', v);
  
  // Check for flush
  var isFlush = ss[0] == (ss[1]|ss[2]|ss[3]|ss[4]);
  var isRoyal = s == 0x7c00;
  console.log('Flush detection:', {
    isFlush,
    isRoyal,
    suits: ss.map(x => x.toString(2).padStart(4, '0'))
  });
  
  v -= isFlush * (isRoyal ? -5 : 1);
  console.log('Final value:', v);
  
  return { 
    handName: hands[v], 
    isAceLowStraight: isAceLowStraight,
    debug: {
      finalIndex: v,
      bitField: s.toString(2).padStart(32, '0'),
      isFlush,
      isStraight: isStraight || isAceLowStraight,
      isRoyal
    }
  };
}
        </code></pre>
      </section>

      <section class="content-section">
        <h2>How It Works: Code Analysis</h2>
        <p class="mb-6">
          The analyzer uses clever bit manipulation and mathematical operations
          to determine poker hand ranks. Let's break down each part of the code
          and understand how it works.
        </p>

        <div class="overflow-x-auto">
          <table class="code-analysis-table">
            <thead>
              <tr>
                <th>Code Segment</th>
                <th>Explanation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>const hands = ["4 of a Kind", ...]</code></td>
                <td>
                  Array mapping final calculated indices to hand names. The
                  order is crucial as the algorithm's mathematical operations
                  are designed to produce these specific indices.
                </td>
              </tr>
              <tr>
                <td><code>const A=14, K=13, Q=12, J=11</code></td>
                <td>
                  Card rank constants with
                  <span class="tech-term"
                    >Ace high<span class="tooltip"
                      ><span class="tooltip-title">Ace High</span
                      ><span class="tooltip-content"
                        >In poker, treating the Ace as the highest card (value
                        14) rather than the lowest (value 1). This affects hand
                        rankings and straight combinations.</span
                      ></span
                    ></span
                  >
                  (14). These values are used in the
                  <span class="tech-term"
                    >bit manipulation<span class="tooltip"
                      ><span class="tooltip-title">Bit Manipulation</span
                      ><span class="tooltip-content"
                        >Operations that work directly with individual bits in
                        binary numbers, including setting, clearing, toggling,
                        and checking bit values.</span
                      ></span
                    ></span
                  >
                  operations to ensure proper hand ranking.
                </td>
              </tr>
              <tr>
                <td><code>const _ = {"♠":1, "♣":2, "♥":4, "♦":8}</code></td>
                <td>
                  <span class="tech-term"
                    >Suit flags<span class="tooltip"
                      ><span class="tooltip-title">Suit Flags</span
                      ><span class="tooltip-content"
                        >Binary values assigned to card suits where each suit
                        gets a unique power of 2, enabling efficient detection
                        of flushes using bitwise operations.</span
                      ></span
                    ></span
                  >
                  using powers of 2, enabling efficient
                  <span class="tech-term"
                    >bitwise operations<span class="tooltip"
                      ><span class="tooltip-title">Bitwise Operations</span
                      ><span class="tooltip-content"
                        >Operations that manipulate individual bits in a number,
                        such as AND (&amp;), OR (|), XOR (^), and bit shifts
                        (&lt;&lt;, &gt;&gt;).</span
                      ></span
                    ></span
                  >
                  for flush detection. Each suit's value is a unique power of 2.
                </td>
              </tr>
              <tr>
                <td><code>s = 1&lt;&lt;cs[0]|1&lt;&lt;cs[1]|...</code></td>
                <td>
                  Creates a
                  <span class="tech-term"
                    >bit field<span class="tooltip"
                      ><span class="tooltip-title">Bit Field</span
                      ><span class="tooltip-content"
                        >A data structure that uses individual bits to store
                        information, where each bit position represents a
                        specific value or state.</span
                      ></span
                    ></span
                  >
                  where each card's rank sets a corresponding bit. For example,
                  a hand of [2,3,4,5,6] creates the binary: ...0000111110
                </td>
              </tr>
              <tr>
                <td><code>for (i=-1, v=o=0; i&lt;5; i++...)</code></td>
                <td>
                  Builds value 'v' encoding card rank counts using
                  <span class="tech-term"
                    >4-bit nibbles<span class="tooltip"
                      ><span class="tooltip-title">4-bit Nibble</span
                      ><span class="tooltip-content"
                        >Half a byte (4 bits) that can represent values from 0
                        to 15. Used here to store the count of each card
                        rank.</span
                      ></span
                    ></span
                  >. Each rank gets 4 bits, allowing count tracking up to 15.
                  Uses
                  <span class="tech-term"
                    >floating-point mantissa<span class="tooltip"
                      ><span class="tooltip-title">Floating-point Mantissa</span
                      ><span class="tooltip-content"
                        >The significant digits of a floating-point number. In
                        JavaScript, provides 52 bits of precision, allowing
                        storage of multiple 4-bit counters.</span
                      ></span
                    ></span
                  >
                  (52 bits) for extended precision.
                </td>
              </tr>
              <tr>
                <td><code>v = v % 15 - (...)</code></td>
                <td>
                  <span class="tech-term"
                    >Modulo 15<span class="tooltip"
                      ><span class="tooltip-title">Modulo 15</span
                      ><span class="tooltip-content"
                        >Mathematical operation that returns the remainder after
                        division by 15, used here to create unique values for
                        different poker hands.</span
                      ></span
                    ></span
                  >
                  creates unique values for different hand types:
                  <ul>
                    <li>High Card: 5</li>
                    <li>One Pair: 6</li>
                    <li>Two Pair: 7</li>
                    <li>Three of Kind: 9</li>
                    <li>Full House: 10</li>
                    <li>Four of Kind: 1 (16%15)</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><code>(s/(s&amp;-s) == 31) || (s == 0x403c)</code></td>
                <td>
                  <span class="tech-term"
                    >Straight detection<span class="tooltip"
                      ><span class="tooltip-title">Straight Detection</span
                      ><span class="tooltip-content"
                        >Algorithm to identify five consecutive card ranks. Uses
                        bit manipulation to check for 5 adjacent set bits in the
                        bit field.</span
                      ></span
                    ></span
                  >
                  using two methods:
                  <ul>
                    <li>
                      <span class="tech-term"
                        >s/(s&amp;-s) == 31<span class="tooltip"
                          ><span class="tooltip-title">Lowest Bit Division</span
                          ><span class="tooltip-content"
                            >Division by the lowest set bit (s&amp;-s) equals 31
                            only when there are exactly 5 consecutive set bits,
                            indicating a straight.</span
                          ></span
                        ></span
                      >: Checks for 5 consecutive bits
                    </li>
                    <li>
                      <span class="tech-term"
                        >s == 0x403c<span class="tooltip"
                          ><span class="tooltip-title"
                            >Hexadecimal Comparison</span
                          ><span class="tooltip-content"
                            >Checks for the specific bit pattern of an Ace-low
                            straight (A,2,3,4,5) using hexadecimal
                            notation.</span
                          ></span
                        ></span
                      >: Special case for Ace-low straight (A,2,3,4,5)
                    </li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td><code>ss[0] == (ss[1]|ss[2]|ss[3]|ss[4])</code></td>
                <td>
                  <span class="tech-term"
                    >Flush detection<span class="tooltip"
                      ><span class="tooltip-title">Flush Detection</span
                      ><span class="tooltip-content"
                        >Algorithm to check if all cards share the same suit by
                        comparing the first card's suit with the bitwise OR of
                        all other suits.</span
                      ></span
                    ></span
                  >
                  by comparing first suit with
                  <span class="tech-term"
                    >bitwise OR<span class="tooltip"
                      ><span class="tooltip-title">Bitwise OR</span
                      ><span class="tooltip-content"
                        >Operation that sets each bit to 1 if either input bit
                        is 1. Used here to combine suit flags for
                        comparison.</span
                      ></span
                    ></span
                  >
                  of others. Works because suit values are powers of 2. True
                  only if all suits match.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="content-section">
        <h2>Bit Field Explanation</h2>
        <div class="container mx-auto max-w-[1200px] px-4">
          <table>
            <thead>
              <tr>
                <th>Card</th>
                <th>Binary Representation (MSB → LSB)</th>
                <th>Explanation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>A♠</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000<span class="bg-amber-400 text-gray-900"
                      >0100</span
                    >0000000<span class="bg-blue-400 text-gray-900"
                      >0001</span
                    ></code
                  >
                </td>
                <td>
                  The Ace of Spades sets two bits: Bit 14 (0100) for the Ace
                  rank and Bit 0 (0001) for the Spades suit. The Ace uses the
                  highest rank position (14) in the leftmost region, while
                  Spades uses the lowest suit position (0) in the rightmost
                  region.
                </td>
              </tr>
              <tr>
                <td>K♣</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000<span class="bg-amber-400 text-gray-900"
                      >0010</span
                    >0000000<span class="bg-blue-400 text-gray-900"
                      >0010</span
                    ></code
                  >
                </td>
                <td>
                  The King of Clubs sets two bits: Bit 13 (0010) for the King
                  rank and Bit 1 (0010) for the Clubs suit. The King uses the
                  second-highest rank position, one position right of the Ace's
                  position.
                </td>
              </tr>
              <tr>
                <td>Q♥</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000<span class="bg-amber-400 text-gray-900"
                      >0001</span
                    >0000000<span class="bg-blue-400 text-gray-900"
                      >0100</span
                    ></code
                  >
                </td>
                <td>
                  The Queen of Hearts sets two bits: Bit 12 (0001) for the Queen
                  rank and Bit 2 (0100) for the Hearts suit. The Queen uses bit
                  position 12, continuing the pattern of face cards using the
                  highest bit positions.
                </td>
              </tr>
              <tr>
                <td>J♦</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000000<span
                      class="bg-amber-400 text-gray-900"
                      >1000</span
                    >0000<span class="bg-blue-400 text-gray-900"
                      >1000</span
                    ></code
                  >
                </td>
                <td>
                  The Jack of Diamonds sets two bits: Bit 11 (1000) for the Jack
                  rank and Bit 3 (1000) for the Diamonds suit. The Jack, as the
                  lowest face card, uses bit position 11, while Diamonds uses
                  the highest suit bit.
                </td>
              </tr>
              <tr>
                <td>5♠</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000000000000<span
                      class="bg-amber-400 text-gray-900"
                      >0010</span
                    ><span class="bg-blue-400 text-gray-900">0001</span></code
                  >
                </td>
                <td>
                  The Five of Spades sets two bits: Bit 5 (0010) for the Five
                  rank and Bit 0 (0001) for the Spades suit. Notice how the rank
                  bit position (5) matches the card's value, making it intuitive
                  to locate.
                </td>
              </tr>
              <tr>
                <td>4♣</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000000000000<span
                      class="bg-amber-400 text-gray-900"
                      >0001</span
                    ><span class="bg-blue-400 text-gray-900">0010</span></code
                  >
                </td>
                <td>
                  The Four of Clubs sets two bits: Bit 4 (0001) for the Four
                  rank and Bit 1 (0010) for the Clubs suit. The rank bit
                  position (4) equals the card's value, continuing the pattern
                  for number cards.
                </td>
              </tr>
              <tr>
                <td>3♥</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000000000000<span
                      class="bg-amber-400 text-gray-900"
                      >0000</span
                    ><span class="bg-blue-400 text-gray-900">0100</span></code
                  >
                </td>
                <td>
                  The Three of Hearts sets two bits: Bit 3 for the Three rank
                  and Bit 2 (0100) for the Hearts suit. The rank bit is now
                  closer to the suit bits as we move to lower values.
                </td>
              </tr>
              <tr>
                <td>2♦</td>
                <td>
                  <code class="text-emerald-400"
                    >00000000000000000000000000<span
                      class="bg-amber-400 text-gray-900"
                      >0000</span
                    ><span class="bg-blue-400 text-gray-900">1000</span></code
                  >
                </td>
                <td>
                  The Two of Diamonds sets two bits: Bit 2 for the Two rank and
                  Bit 3 (1000) for the Diamonds suit. This is the lowest rank,
                  using bit position 2, while still maintaining the same suit
                  bit pattern.
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <section class="content-section">
        <h2>Bit Reference Tables</h2>
        <div class="tab-container">
          <!-- Tables will be dynamically generated here -->
        </div>
      </section>

      <section class="content-section">
        <h2>Interactive Demo</h2>
        <p>
          Click the button below to deal a random 5-card hand and see the
          analyzer determine its rank. The visualization below shows how the
          bitwise operations work.
        </p>

        <div class="text-center mb-6">
          <button id="dealButton" class="deal-button">Deal New Hand</button>
        </div>

        <div
          id="handDisplay"
          role="region"
          aria-label="Current poker hand display"
          class="flex flex-wrap justify-center items-center mb-4 min-h-[7rem]"
        >
          <!-- Initial placeholder cards -->
          <div class="card placeholder" role="img" aria-label="Card back"></div>
          <div class="card placeholder" role="img" aria-label="Card back"></div>
          <div class="card placeholder" role="img" aria-label="Card back"></div>
          <div class="card placeholder" role="img" aria-label="Card back"></div>
          <div class="card placeholder" role="img" aria-label="Card back"></div>
        </div>

        <div
          id="resultDisplay"
          role="status"
          aria-live="polite"
          class="text-center font-semibold text-xl min-h-[2rem]"
        ></div>

        <div id="stepAnalysis" class="mt-8 space-y-6 hidden">
          <h2 class="text-2xl font-bold text-gray-100 mb-4">
            Step-by-Step Analysis
          </h2>

          <!-- Step 1: Initial Hand -->
          <div id="step1" class="step-card bg-gray-800 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-blue-400 mb-4">
              Step 1: Individual Card Bits
            </h3>
            <p class="text-gray-300 mb-4">
              Each card sets its rank bit (2-14) and suit bit (0-3):
            </p>
            <div class="hand-details space-y-2">
              <!-- Will be populated by JavaScript -->
            </div>
          </div>

          <!-- Step 2: Bit Field Construction -->
          <div id="step2" class="step-card bg-gray-800 p-6 rounded-lg">
            Text here
          </div>

          <!-- Step 3: Pattern Analysis -->
          <div id="step3" class="step-card bg-gray-800 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-blue-400 mb-4">
              Step 3: Pattern Analysis
            </h3>
            <div class="pattern-details mb-4">
              <!-- Will be populated by JavaScript -->
            </div>
            <div class="straight-check mb-4">
              <!-- Will be populated by JavaScript -->
            </div>
            <div class="flush-check">
              <!-- Will be populated by JavaScript -->
            </div>
          </div>

          <!-- Step 4: Final Calculation -->
          <div id="step4" class="step-card bg-gray-800 p-6 rounded-lg">
            <h3 class="text-xl font-semibold text-blue-400 mb-4">
              Step 4: Hand Rank Calculation
            </h3>
            <div class="calculation-details mb-4">
              <!-- Will be populated by JavaScript -->
            </div>
            <div class="final-result text-2xl font-bold text-emerald-400">
              <!-- Will be populated by JavaScript -->
            </div>
          </div>
        </div>
      </section>
    </div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>
